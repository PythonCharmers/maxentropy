"""
Utility routines for the maxentropy package.

License: BSD-style (see LICENSE.md in main source directory)
"""

from types import FunctionType, GeneratorType

import numpy as np

# from numpy import log, exp, asarray, ndarray, empty
import scipy.sparse
from scipy.special import logsumexp


__all__ = ["DivergenceError"]


class DivergenceError(Exception):
    """Exception raised if the entropy dual has no finite minimum."""

    def __init__(self, message):
        self.message = message
        Exception.__init__(self)

    def __str__(self):
        return repr(self.message)


def auxiliary_sampler_scipy(distribution, n_dims=1, n_samples=1):
    """
    A generator function for samples from the given scipy.stats distribution.

    Parameters
    ----------
    distribution : a scipy.stats distribution object (rv_frozen)

    n_dims: the number of dimensions we want in our samples (each
         using the same distribution object)

    n_samples: the number of samples to generate and yield in each iteration

    Returns
    -------
    A generator that yields tuples of length 2:
        (xs, log_q_xs)
    where:
        xs : matrix (n_samples x n_dims): [x_1, ..., x_n]: a sample
        log_q_xs: log pdf values under the auxiliary sampler for each x_j (for j = 1 through n)

    """
    size = (n_samples, n_dims)
    while True:
        xs = distribution.rvs(size=size)
        log_q_xs = np.log(distribution.pdf(xs.T)).sum(axis=0)
        yield (xs, log_q_xs)


# def feature_sampler_vec(vec_f: FunctionType, auxiliary_sampler: GeneratorType):
#     """
#     A generator function for features at random points xs on the sample space.
#     Yields tuples (F, log_q_xs, xs), defined below. Takes a single vectorized
#     function vec_f.
#
#     Parameters
#     ----------
#     vec_f : function
#         Pass `vec_f` as a vectorized function that operates on a vector of
#         samples xs = {x1,...,xn} and returns a feature matrix (m x n), where m
#         is some number of feature components.
#
#     sampler : generator
#         Pass `sampler` as a generator that yields tuples (xs,
#         log_q_xs) representing a sample to use for sampling (e.g. importance
#         sampling) on the sample space of the model, which must be:
#
#         xs : list, 1d ndarray, or 2d matrix (n x d)
#             The samples generated by `sampler`. We require len(xs) == n.
#
#         log_q_xs : list or 1d ndarray of shape (n,)
#             The log pdf values of the samples xs under the probability
#             distribution q(x) that governs `sampler`.
#
#
#     Yields
#     ------
#         tuples (F, log_q_xs, xs)
#
#         F : array or scipy.sparse matrix of shape (m x n)
#
#         log_q_xs : as yielded by auxiliary_sampler
#
#         xs : as yielded by auxiliary_sampler
#
#     """
#     while True:
#         xs, log_q_xs = next(auxiliary_sampler)
#         F = vec_f(xs)  # compute feature matrix from points
#         yield F, log_q_xs, xs


# Previously sampleFgen, with different argument order
def feature_sampler(
    features: list[FunctionType],
    sampler: GeneratorType,
    *,
    matrix_format: str = "csc_matrix",
    vectorized: bool = False,
    dtype=float,
    omit_samples=False,
):
    """
    A generator function that yields features of random points.

    Parameters
    ----------
        features : list of functions
            Pass `features` as a list of d feature functions f_i to apply to the
            outputs yielded by `sampler`.

        sampler : generator
            `sampler` must be a generator that yields tuples (xs, log_q_xs)
            representing a sample to use for sampling (e.g. importance sampling)
            on the sample space of the model, which must be:

            - xs : list, 1d ndarray, or 2d matrix (n x m)
                   The samples generated by `sampler`. We require len(xs) == n.

            - log_q_xs : list or 1d ndarray of shape (n,)
                         The log pdf values of the samples xs under the
                         probability distribution q(x) that governs `sampler`.


        matrix_format: str
            The output format for the matrices F we yield. Either 'ndarray' for a
            dense array or a format string understood by scipy.sparse, such as
            'csc_matrix', 'csr_matrix' etc.  for constructing a scipy.sparse
            matrix of features

        vectorized: bool
            If True, the feature functions f_i are assumed to be vectorized;
            then these will be passed all observations xs at once, in turn.

            If False, the feature functions f_i will be evaluated on each x in the
            sample xs, one at a time.

        dtype: a NumPy-compatible dtype for the output matrix.

        omit_samples: bool
            Whether to yield values of None for the sample xs.
            Passing omit_samples = True saves memory, since fitting the model
            doesn't require these, only the features. But having the samples makes
            the model easier to inspect / understand / debug.

    Yields
    ------
    If omit_samples is False, the generator yields the tuple:
        (F, logprobs, xs)
    Or if omit_samples is True, the generator yields the tuple:
        (F, logprobs)

    where:
        - F is the computed dense or sparse feature matrix (of size n x d)
        - logprobs is the same vector of log probs yielded by sampler (length n)
        - xs is the sample yielded by auxiliary_sampler (length n)

    """
    while True:
        xs, logprobs = next(sampler)
        # Previously:
        # F = utils.sparsefeaturematrix(features, xs, sparse_format)
        # but the function evaluate_feature_matrix() is now superior.
        F = evaluate_feature_matrix(
            features,
            xs,
            vectorized=vectorized,
            matrix_format=matrix_format,
            dtype=dtype,
        )
        if omit_samples:
            yield F, logprobs
        else:
            yield F, logprobs, xs


def evaluate_feature_matrix(
    feature_functions: list,
    xs: list | np.ndarray,
    *,
    vectorized: bool = False,
    matrix_format: bool = "csc_matrix",
    dtype=float,
    verbose: bool = False,
):
    """Evaluate a (n x d) matrix of features `F` of the sample `xs` as:

        F[:, i] = f_i(xs)

    if xs is 1D, or as:

        F[j, i] = f_i(xs[j, :])

    if xs is 2D, for each feature function `f_i` in `feature_functions`.

    Parameters
    ----------
    feature_functions :
        a list of d feature functions f_i.

    xs : either:
        1. a 1d array or sequence (e.g list) of observations [x_j
           for j=1,...,n].
        2. a (n x m) matrix representing n m-dimensional
           observations xs[j, :] for j=1,...,n.

    vectorized : bool (default False)
        If True, the feature functions f_i are assumed to be vectorized;
        then these will be passed all observations xs at once, in turn.

        If False, the feature functions f_i will be evaluated on each x in the
        sample xs, one at a time.

    matrix_format : str (default 'csc_matrix')
        Options: 'ndarray', 'csc_matrix', 'csr_matrix', 'dok_matrix'.
        If you have enough memory, it may be faster to create a dense
        ndarray and then construct a e.g. CSC matrix from this.

    Returns
    -------
    F : (n x d) matrix (in the given matrix format: ndarray / csc_matrix / etc.)
        Matrix of evaluated features.

    """
    d = len(feature_functions)

    if isinstance(xs, np.ndarray) and xs.ndim == 2:
        n, m = xs.shape
        if m == 1 and vectorized:
            # xs may be a column vector, i.e. (n x 1) array.
            # In this case, reshape it to a 1d array. This
            # makes it easier to define functions that
            # operate on only one variable (a common case)
            # given that sklearn's interface now forces 2D
            # arrays X when calling .transform(X) and .fit(X).
            xs = np.reshape(xs, n)
    else:
        n, m = len(xs), 1

    if matrix_format in ("dok_matrix", "csc_matrix", "csr_matrix"):
        F = scipy.sparse.dok_matrix((n, d), dtype=dtype)
    elif matrix_format == "ndarray":
        F = np.zeros((n, d), dtype=dtype)
    else:
        raise ValueError("matrix format not recognized")

    for i, f_i in enumerate(feature_functions):
        if verbose:
            print(f"Computing feature {i=} of {d=} ...")
        if vectorized:
            F[:, i] = f_i(xs)
        else:
            for j in range(n):
                f_i_xj = f_i(xs[j])
                if f_i_xj != 0:
                    F[j, i] = f_i_xj
    if verbose:
        print("Finished computing features.")

    if matrix_format == "csc_matrix":
        return F.tocsc()
    elif matrix_format == "csr_matrix":
        return F.tocsr()
    else:
        return F


# def densefeaturematrix(f, sample, verbose=False):
#     """Compute an (m x n) dense array of non-zero evaluations of the
#     scalar functions fi in the list f at the points x_1,...,x_n in the
#     list sample.
#     """
#
#     # Was: return np.array([[fi(x) for fi in f] for x in sample])
#
#     m = len(f)
#     n = len(sample)
#
#     F = np.empty((m, n), float)
#     for i in range(m):
#         f_i = f[i]
#         for j in range(n):
#             x = sample[j]
#             F[i,j] = f_i(x)
#     return F


def _test():
    import doctest

    doctest.testmod()


if __name__ == "__main__":
    _test()
